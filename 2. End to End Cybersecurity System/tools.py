import copy, struct, sys, uuid, random, math, fractions
from OpenSSL import crypto, SSL

# Name: Mersinias Michail
# AM: 2013030057

# Lookup Tables needed for AES and SHA-2

SBOX = (
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
)

InvSBOX = (
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
)

Rcon = (
	0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
	0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
	0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
	0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39
)

Mix_Columns_2 = (
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
)

Mix_Columns_3 = (
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
)

Mix_Columns_9 = (
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
)

Mix_Columns_11 = (
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
)

Mix_Columns_13 = (
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
)

Mix_Columns_14 = (
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
)

k= (
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
)

ht = (
	0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
)


# Functions for file operations

def file_read_line(name):
	file_temp_r = open(name, "r")
	r_res = file_temp_r.readline()
	file_temp_r.close()
	return r_res

def file_write_line(name, the_text):
	file_temp_w = open(name, "w")
	w_res = file_temp_w.write(the_text)
	file_temp_w.close()
	return len(str(the_text))


def file_read(name):
	file_temp_r = open(name, "r")
	r_res = file_temp_r.read()
	file_temp_r.close()
	return r_res

def file_write(name, the_text):
	file_temp_w = open(name, "w")
	w_res = file_temp_w.write(the_text)
	file_temp_w.close()
	return len(str(the_text))


# Functions in case we want a byte array as I/O instead of a string, or a string instead of a byte array

def string_to_byte_array(the_string):
	res_byte = []
	pos = 0
	
	while(pos<len(the_string)):
		next_pos = the_string.find('|', pos)
		res_byte.append(the_string[pos:next_pos])
		pos = next_pos+1

	return res_byte

def byte_array_to_string(the_byte_array):
	str_res = ''

	for i in the_byte_array:
		str_res = str_res + str(i) + '|'

	return str_res





# Questions 1: AES, main source: http://www.formaestudio.com/rijndaelinspector/archivos/Rijndael_Animation_v4_eng.swf

#Functions needed to switch between list and hex

def list2hex(list):
	hex = ""
	for e in list:
		hex += "{:02x}".format(e)
	return hex

def hex2list(hex):
	lst = []
	if len(hex) % 2 == 0:
		for i in range(len(hex)/2):
			lst.append(int(hex[i*2:i*2+2], 16))
		return lst


# Padding needed for the data input

def aes_padding(msg):
#    while (len(msg)%16!=0):
#        msg = '0' + msg
#	return msg.encode("hex")

	text_length = len(msg)

	msg = msg.encode("hex")

	pad_mod = text_length%16
	pad_times = 16-pad_mod

	pad_num = str(hex(pad_times)[2:].zfill(2))

	pad_i = pad_times

	
	if (pad_mod==0):
		pad_i = 16

	while (pad_i>0):
		msg = msg + pad_num
		pad_i=pad_i-1
	return msg


def aes_reverse_padding(padded_msg):
	last_digits = padded_msg[-2:]
	
	times_to_remove = int(last_digits, 16)
	new_len = len(padded_msg)-2*times_to_remove
	return padded_msg[0:new_len].decode("hex")



# AES key generation functions (random based on length and based on a password)

def get_IV():
	return '0102030405060708090a0b0c0d0e0f10'

def aes_key_generation(key_length):

	key_down = pow(10, key_length+2)

	key_up = (pow(10, key_length+3)-1)

	key_rand = random.randrange(key_down, key_up)

	key_res = hex(key_rand)[2:]

	key_res = key_res[:len(key_res)-1]

	return key_res

def aes_pw_key_generation(pas):
	return pas.encode("hex")

#Expand key function in order to generate keys for each loop in the encrypt/decrypt AES function

def expand_key(key):

	expanded_key = key

	key_size = len(key)

	if(key_size!=16):
		print 'incorrect key size'

	
	word = expanded_key[-4:]

	for i in xrange(1, 11):

		# left-rotate by 1 byte
		word = word[1:4] + word[0:1]

		# apply S-box to all bytes
		for j in xrange(4):
			word[j] = SBOX[word[j]]

		# apply the Rcon table to the left byte
		word[0] ^= Rcon[i]

		for z in xrange(4):
			for j in xrange(4):
				# mix in bytes from the last subkey
				word[j] ^= expanded_key[-key_size + j]
			expanded_key.extend(word)

	return expanded_key


# sub_bytes and shift_rows functions, quite straightforward

def test_sub_bytes(state):
	for i in range(16):
		state[i] = SBOX[state[i]]
	return state


def test_shift_rows(state):
	state[1],  state[5],  state[9],  state[13] = state[5],  state[9],  state[13], state[1]
	state[2],  state[6],  state[10], state[14] = state[10], state[14], state[2],  state[6]
	state[3],  state[7],  state[11], state[15] = state[15], state[3],  state[7],  state[11]
	return state

# Implementing mix_columns function based on the equations shown inside

def test_mix_columns(state):
	# r0 = 2*a0 + 3*a1 + a2   + a3
	# r1 = a0   + 2*a1 + 3*a2 + a3
	# r2 = a0   + a1   + 2*a2 + 3*a3
	# r3 = 3*a0 + a1   + a2   + 2*a3

	for i in xrange(0, 16, 4):
		temp0 = state[i]
		temp1 = state[i+1]
		temp2 = state[i+2]
		temp3 = state[i+3]

		state[i] = Mix_Columns_2[temp0] ^ Mix_Columns_3[temp1] ^ temp2 ^ temp3
		state[i+1] = temp0 ^ Mix_Columns_2[temp1] ^ Mix_Columns_3[temp2] ^ temp3
		state[i+2] = temp0 ^ temp1 ^ Mix_Columns_2[temp2] ^ Mix_Columns_3[temp3]
		state[i+3] = Mix_Columns_3[temp0] ^ temp1 ^ temp2 ^ Mix_Columns_2[temp3]

	return state

# Add_round_key function, just a XOR between 2 lists

def test_add_round_key(state, roundkey):
	for i in range(16):
		state[i] = state[i] ^ roundkey[i]

	return state

# Decryption functions implemented accordingly, but the other way around

def test_inv_sub_bytes(state):
	for i in range(16):
		state[i] = InvSBOX[state[i]]
	return state


def test_inv_shift_rows(state):
	state[5],  state[9],  state[13], state[1]  = state[1],  state[5],  state[9],  state[13]
	state[10], state[14], state[2],  state[6]  = state[2],  state[6],  state[10], state[14]
	state[15], state[3],  state[7],  state[11] = state[3],  state[7],  state[11], state[15]
	return state


def test_inv_mix_columns(state):
	# r0 = 14*a0 + 11*a1 + 13*a2 +  9*a3
	# r1 =  9*a0 + 14*a1 + 11*a2 + 13*a3
	# r2 = 13*a0 +  9*a1 + 14*a2 + 11*a3
	# r3 = 11*a0 + 13*a1 +  9*a2 + 14*a3

	for i in xrange(0, 16, 4):
		inv_temp0 = state[i]
		inv_temp1 = state[i+1]
		inv_temp2 = state[i+2]
		inv_temp3 = state[i+3]

		state[i] = Mix_Columns_14[inv_temp0] ^ Mix_Columns_11[inv_temp1] ^ Mix_Columns_13[inv_temp2] ^ Mix_Columns_9[inv_temp3]  
		state[i+1] = Mix_Columns_9[inv_temp0] ^ Mix_Columns_14[inv_temp1] ^ Mix_Columns_11[inv_temp2] ^ Mix_Columns_13[inv_temp3]
		state[i+2] = Mix_Columns_13[inv_temp0] ^ Mix_Columns_9[inv_temp1] ^ Mix_Columns_14[inv_temp2] ^ Mix_Columns_11[inv_temp3]
		state[i+3] = Mix_Columns_11[inv_temp0] ^ Mix_Columns_13[inv_temp1] ^ Mix_Columns_9[inv_temp2] ^ Mix_Columns_14[inv_temp3]

	return state

# Main AES encrypt function as described on the presentation and wikipedia

def aes_encrypt(data, key):
	key = (hex2list(key))
	the_input = (hex2list(data))

	exp_key1 = expand_key(key)

	begin_1 = test_add_round_key(the_input, exp_key1[0:16])

	for i in range(1, 11):
		if(i==1):
			first = test_sub_bytes(begin_1)
		else:
			first = test_sub_bytes(fourth)

		second = test_shift_rows(first)

		if(i<10):
			third = test_mix_columns(second)
			fourth = test_add_round_key(third, exp_key1[i*16:(i+1)*16])
		else:
			fourth = test_add_round_key(second, exp_key1[len(exp_key1)-16:])

	return list2hex(fourth)


# Main AES decrypt function as described on the presentation and wikipedia

def aes_decrypt(data, key):
	key = (hex2list(key))
	the_input = (hex2list(data))
	exp_key2 = expand_key(key)

	for i in range(1, 11):
		if(i==1):
			fifth = test_add_round_key(the_input, exp_key2[len(exp_key2)-16:])
		else:
			fifth = test_add_round_key(final, exp_key2[(11-i)*16:(11-i+1)*16])

		if(i>1):
			sixth = test_inv_mix_columns(fifth)
			seventh = test_inv_shift_rows(sixth)
		else:
			seventh = test_inv_shift_rows(fifth)

		final = test_inv_sub_bytes(seventh)

	#print key
	last_1 = test_add_round_key(final, exp_key2[0:16])

	end = list2hex(final)
	return end

# ECB mode functions

def ECB_encrypt(ecb_plaintext, ecb_key):
	ecb_data = [0 for row in range(0,len(str(ecb_plaintext)))]
	ecb_final = ''

	if (len(str(ecb_plaintext))>32):
		ecb_times = int(math.ceil(len(str(ecb_plaintext))/32))

		for i in xrange(ecb_times):
			ecb_data[i] = str(ecb_plaintext)[i*32:(i+1)*32]
			ecb_res = aes_encrypt(ecb_data[i], ecb_key)
			ecb_final = ecb_final + ecb_res

		return ecb_final
	else:
		return aes_encrypt(str(ecb_plaintext), ecb_key)


def ECB_decrypt(ecb_cyphertext, ecb_key):
	ecb_data = [0 for row in range(0,len(str(ecb_cyphertext)))]
	ecb_final = ''

	if (len(str(ecb_cyphertext))>32):
		ecb_times = int(math.ceil(len(str(ecb_cyphertext))/32))

		for i in xrange(ecb_times):
			ecb_data[i] = str(ecb_cyphertext)[i*32:(i+1)*32]
			ecb_res = aes_decrypt(ecb_data[i], ecb_key)
			ecb_final = ecb_final + ecb_res

		return ecb_final
	else:
		return aes_decrypt(str(ecb_cyphertext), ecb_key)


# CBC mode functions, plus a support cbc_xor function

def cbc_xor(a, b):
	c = ''

	for i in xrange(len(str(a))):
		t1=int(a[i],16) ^ int(b[i],16)
		c=c+hex(t1)[2:]
#    print c
#    print len(c)
	return c


def CBC_encrypt(cbc_cyphertext, cbc_key, cbc_IV):
	cbc_final = ''

	cbc_times = int(math.ceil(len(str(cbc_cyphertext))/32))
	
#   print cbc_times

	for i in xrange(cbc_times):
		temp2 = cbc_xor(cbc_cyphertext[i*32:(i+1)*32], cbc_IV)
		cbc_IV = aes_encrypt(temp2, cbc_key)
		cbc_final = cbc_final + cbc_IV

	return cbc_final


def CBC_decrypt(cbc_cyphertext, cbc_key, cbc_IV):
	cbc_final = ''

	cbc_times = int(math.ceil(len(str(cbc_cyphertext))/32))
	
#   print cbc_times

	for i in xrange(cbc_times):
		temp = aes_decrypt(cbc_cyphertext[i*32:(i+1)*32], cbc_key)
		temp2 = cbc_xor(temp, cbc_IV)
		cbc_final = cbc_final + temp2
		cbc_IV = cbc_cyphertext[i*32:(i+1)*32]

	return cbc_final









# RSA - Key Generation, main sources: wi


# Mathematical functions based on wikipedia/wikibooks, main source: https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm

def xgcd(b, n):
	x0, x1, y0, y1 = 1, 0, 0, 1
	while n != 0:
		q, b, n = b // n, n, b % n
		x0, x1 = x1, x0 - q * x1
		y0, y1 = y1, y0 - q * y1
	return  b, x0, y0

def modinv(a, m):
	g, x, y = xgcd(a, m)
	if g != 1:
		raise Exception('modular inverse does not exist')
	else:
		return x % m


# Simple implementation of fermat primality test

def fermat_is_prime(num):
	if (num == 2):
		return True
	return pow(2, num-1, num) == 1


# Getting a random prime number in range limit_down to limit_up

def get_random_prime_number(limit_down, limit_up):
  
	prime = random.randint(limit_down, limit_up)

	if(prime%2==0):
		prime = prime + 1

	while(prime<limit_up):
		if(fermat_is_prime(prime)==True):
			break
		prime = random.randint(limit_down, limit_up)
		while(prime%2==0):
			prime = random.randint(limit_down, limit_up)

	return prime


# Function to generate 2 random numbers p, q so that len(p*q)=desired length

def generate_numbers(l):

	l = l/8

	down = 1
	up = 1

	down = pow(10, (int(math.ceil((l/2)))-1))

	up = (pow(10, (int(math.ceil((l/2)))))-1)

	if(l%2==1):
		p = get_random_prime_number((down*10), (up*10))
		q = get_random_prime_number(down, up)

		while(len(str(p*q))<l):
			p = get_random_prime_number(down*10, up*10)
			q = get_random_prime_number(down, up)
	else:
		p = get_random_prime_number(down, up)
		q = get_random_prime_number(down, up)

		while(len(str(p*q))<l):
			p = get_random_prime_number(down, up)
			q = get_random_prime_number(down, up)

	return (p,q)

# Creating a key pair, a public key and a private key, based on the RSA algorithm decribed on wikipedia: https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Key_generation

def create_key_pair(p, q):

	n = p * q

	phi = (p-1) * (q-1)

	e = random.randrange(1, phi)

	while(fractions.gcd(e, phi)!=1):
		e = random.randrange(1, phi)

	d = modinv(e,phi)

	return ((e, n), (d, n))


# Main RSA key generation function

def key_generation(l):
	
	prime_nums = generate_numbers(l)
	
	key_pair = create_key_pair(prime_nums[0], prime_nums[1])

	#print 'First prime: ',prime_nums[0]
	#print 'Second prime: ',prime_nums[1]

	#print 'e is: ',key_pair[0][0]
	#print 'n is: ',key_pair[0][1]
	#print 'd is: ',key_pair[1][0]
	#print 'n is: ',key_pair[1][1]
	print "RSA key pair was generated successfully!"
	return key_pair









# RSA - Encryption / Decryption, based on wikipedia as well and making use of byte arrays, it is made to accept and return string though

def rsa_encrypt(m, e, n):
	c = []

	m_ar = bytearray()
	m_ar.extend(m)

	for i in xrange(len(m_ar)):
		c.append(pow(m_ar[i], e, n))

	return c

def rsa_decrypt(c, d, n):
	m = []
	rsa_res = ''

	for i in xrange(len(c)):
		m.append(pow(int(c[i]), d, n))

	for i in xrange(len(m)):
		rsa_res = rsa_res + chr(m[i])

	# return m
	return rsa_res









# SHA-256, largely based on wikipedia and stackoverflow pseudocode, especially the main SHA256 function

# Pre processing padding

def test_string_to_binary (input_string):
	A = ''.join(format(ord(x), 'b').zfill(8) for x in input_string)
	return A

def append_bit_1 (input_string):
	input_string = input_string + '1'
	return input_string

def append_k_bit (input_string):
	if (len(input_string) % 512 == 448):
		return input_string
	else:
		while (len(input_string) % 512 != 448):
			input_string = input_string + '0'
		return input_string

def append_length_of_message (input_string):

	msg_len = format(len(input_string),'b')

	final_num = ''
	length = 64-len(msg_len)
	for x in range(length):
		final_num = final_num + '0'

	final_num = final_num + msg_len

	return final_num

def padding(input_string):
	# Transform string to binary
	binary_string = test_string_to_binary (input_string)

	# Append '1' at the end of the previous string
	appended_1_bit_string = append_bit_1 (binary_string)

	# Append k bits at the end of the previous string in order to have length % 512 == 448
	appended_k_string = append_k_bit (appended_1_bit_string)

	# Append length of message in the end of the previous string
	length_of_message = append_length_of_message (binary_string)
	final_message = appended_k_string + length_of_message

	return final_message


# SHA-2 sub-functions needed for the main function, based on wikipedia. Rotate_right function based on: https://www.quora.com/How-can-I-represent-the-SHA256-hashing-algorithm-in-python

def rotate_right(a,b):
	return ((a >> b) | (a << (32-b))) & 0xFFFFFFFF

def CH(x,y,z):
	return (((x) & (y)) ^ (~(x) & (z)))

def MAJ(x,y,z):
	return (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

def S0(x):
	return (rotate_right(x,2) ^ rotate_right(x,13) ^ rotate_right(x,22))

def S1(x):
	return (rotate_right(x,6) ^ rotate_right(x,11) ^ rotate_right(x,25))

def SIG0(x):
	return (rotate_right(x,7) ^ rotate_right(x,18) ^ ((x) >> 3))

def SIG1(x):
	return (rotate_right(x,17) ^ rotate_right(x,19) ^ ((x) >> 10))


def SHA256(input_message):

	# Pre-processing:
	message = padding(input_message)

	#print message

	# Process the message in successive 512-bit chunks:
	t = 0

	temp_list=[[0 for row in range(0,len(message))] for col in range(0,511)]
	msg_list=[0 for row in range(0,511)]

	for j in xrange(len(message)):
		temp_list[t][j] = message[j]
		msg_list[t] = temp_list[t][t*512:(t+1)*512]

		if((j+1)%512==0):
			t = t+1


	h0 = ht[0]
	h1 = ht[1]
	h2 = ht[2]
	h3 = ht[3]
	h4 = ht[4]
	h5 = ht[5]
	h6 = ht[6]
	h7 = ht[7]



	#The following part is based on wikipedia's pseudocode found here: https://en.wikipedia.org/wiki/SHA-2#Pseudocode

	# For each chunk
	for chunk in xrange(t): # t = len(message)/512

		w = [0 for row in xrange(64)]

		for i in xrange(16):
			w[i] = int(message[chunk*512+i*32:chunk*512+(i+1)*32], 2)
			#print message[0:32]
			#print bin(w[i])

		for i in range(16, 64):

			sig0 = SIG0(w[i-15])
			sig1 = SIG1(w[i-2])
			w[i] = (w[i-16] + sig0 + w[i-7] + sig1) & 0xFFFFFFFF

		a = h0
		b = h1
		c = h2
		d = h3
		e = h4
		f = h5
		g = h6
		h = h7

		for v in xrange(64):
			S1t = S1(e)
			ch = CH(e, f, g)
			temp1 = (h + S1t + ch + k[v] + w[v]) & 0xFFFFFFFF
			S0t = S0(a)
			maj = MAJ(a, b, c)
			temp2 = (S0t + maj) & 0xFFFFFFFF

			h = g
			g = f
			f = e
			e = (d + temp1) & 0xFFFFFFFF
			d = c
			c = b
			b = a
			a = (temp1 + temp2) & 0xFFFFFFFF

		h0 = (h0 + a) & 0xFFFFFFFF
		h1 = (h1 + b) & 0xFFFFFFFF
		h2 = (h2 + c) & 0xFFFFFFFF
		h3 = (h3 + d) & 0xFFFFFFFF
		h4 = (h4 + e) & 0xFFFFFFFF
		h5 = (h5 + f) & 0xFFFFFFFF
		h6 = (h6 + g) & 0xFFFFFFFF
		h7 = (h7 + h) & 0xFFFFFFFF


	# The following part is about getting the right result in hex form and correctly padded

	h0 = bin(h0)[2:]
	h1 = bin(h1)[2:]
	h2 = bin(h2)[2:]
	h3 = bin(h3)[2:]
	h4 = bin(h4)[2:]
	h5 = bin(h5)[2:]
	h6 = bin(h6)[2:]
	h7 = bin(h7)[2:]

	while (len(h0)<32):
		h0 = '0'+h0

	while (len(h1)<32):
		h1 = '0'+h1

	while (len(h2)<32):
		h2 = '0'+h2

	while (len(h3)<32):
		h3 = '0'+h3

	while (len(h4)<32):
		h4 = '0'+h4

	while (len(h5)<32):
		h5 = '0'+h5

	while (len(h6)<32):
		h6 = '0'+h6

	while (len(h7)<32):
		h7 = '0'+h7
	
	digest = (h0+h1+h2+h3+h4+h5+h6+h7)

	digest_hex = hex(int(digest, 2))

	digest_hex = digest_hex[2:len(digest_hex)-1]

	while (len(digest_hex)<64):
		digest_hex = '0'+digest_hex

	return digest_hex







# Sign and verify functions based on wikipedia (how they work-2nd paragraph): https://en.wikipedia.org/wiki/Digital_signature#How_they_work

def sign(msg, d, n):

	m = SHA256(msg)

	sign_signature = pow(int(m, 16), d, n)

	return sign_signature

def verify(msg, signature, e, n):

	m = SHA256(msg)

	ver = pow(signature, e, n)

	if(str(int(m, 16))==str(ver)):
		return True
	else:
		return False







# Password generation, salt can be added if necessary

def generate_hashed_password(password):
#	salt = uuid.uuid4().hex
#	return SHA256(salt.encode() + password.encode())
	return SHA256(password)


# A pick_key() function for AES so the user can generate the key in the way he wants

def pick_key():
	print 'Press 1 to select a random key based on length'
	print 'Press 2 to select a key based on password'
	print 'Press 3 to select a key based on hashed password'
	print 'Press 4 to write your own key (as hex)'

	little_choice = input("Make your choice: ")

	if(little_choice==1):
		param = input("Please insert the desired key length: ")
		the_key = aes_key_generation(param)
	elif(little_choice==2):
		param = raw_input("Please insert the password: ")
		the_key = aes_pw_key_generation(param)
	elif(little_choice==3):
		param = raw_input("Please insert the password: ")
		the_key = generate_hashed_password(param)
	elif(little_choice==4):
		the_key = raw_input("Please enter your key: ")

	if(len(str(the_key))>32):
		the_key = the_key[0:32]
	else:
		while(len(str(the_key))<32):
			the_key = the_key + '0'

	print 'Key: ',the_key
	return the_key


def verify_certificate(content):
#	print "Certificate verification"

	cert_ver = crypto.load_certificate(crypto.FILETYPE_PEM, content)

	issuer = cert_ver.get_issuer().get_components()
	expiration = cert_ver.get_notAfter()

	iss = issuer[-1][1]

	subj = cert_ver.get_subject().get_components()
	subj = subj[-1][1]

	if(cert_ver.has_expired()==False and iss==subj):
		print "True"
		return True
	else:
		print "False"
		return False






# Main function: The menu and some processes in order to make it user friendly and to make sure of correct inputs. Unfortunately, at the cost of even more code

def my_main():

	option = 10
	mode = 'a'
	rsa_enc = [1467475930L, 573131644L, 139212273L]
	flag_option = 0

	while(option!=0):

		print 'Press 1 to select AES'
		print 'Press 2 to select RSA - Key Generation'
		print 'Press 3 to select RSA - Encrypt / Decrypt (generate keys with option 2 first)'
		print 'Press 4 to select SHA-2'
		print 'Press 5 to select Digital Signature Sign / Verify (generate keys with option 2 first)'
		print 'Press 6 to select Password'
		print 'Press 0 to exit'

		option = input("Make your choice: ")

		if(option==1):
			extra_option_0 = input("Press 1 for encryption or 2 for decryption: ")

			if(extra_option_0==1):
				mode = raw_input("Please enter the mode of operation: ")
				while(mode!='ECB' and mode!='ecb' and mode!='CBC' and mode!='cbc' and mode!=0):
					mode = raw_input("Please enter a correct mode of operation or press 0 to exit: ")

				aes_data = raw_input("Please enter the message: ")
				aes_data = aes_padding(aes_data)
				print 'Original message: ',aes_data
				aes_key = pick_key()

				if(mode=='ECB' or mode=='ecb'):
					ecb_ecn = ECB_encrypt(aes_data, aes_key)
					print 'Encrypted message: ',ecb_ecn
				elif(mode=='CBC' or mode=='cbc'):
					i_v = raw_input("Please enter the initialization vector: ")
					while(len(str(i_v))<32):
						print 'Recommended: 0102030405060708090a0b0c0d0e0f10'
						i_v = raw_input("Please enter a correctly sized initialization vector: ")
					
					cbc_enc = CBC_encrypt(aes_data, aes_key, i_v)
					print 'Encrypted message: ',cbc_enc

				aes_file_name = "aes_file.txt"
				file_write_line(aes_file_name, aes_key)

			elif(extra_option_0==2):
				new_mode = raw_input("Please enter the mode of operation: ")
				while(new_mode!='ECB' and new_mode!='ecb' and new_mode!='CBC' and new_mode!='cbc' and new_mode!=0):
					new_mode = raw_input("Please enter a correct mode of operation or press 0 to exit: ")

				if(new_mode==mode):
					choice1 = input('Press 1 if you wish to decrypt the message you just encrypted: ')
					aes_file_name = "aes_file.txt"
					if(choice1==1):
						key_temp = file_read_line(aes_file_name)
						aes_key = key_temp
				else:
					choice1 = 0

				if(new_mode=='ECB' or new_mode=='ecb'):
					if(choice1==1):
						aes_data = ecb_ecn
					else:
						aes_data = raw_input("Please enter the message: ")
						aes_data = aes_padding(aes_data)
						aes_key = pick_key()

					print 'Decrypted message: ',ECB_decrypt(aes_data, aes_key)

				elif(new_mode=='CBC' or new_mode=='cbc'):
					if(choice1==1):
						aes_data = cbc_enc
						i_v = i_v
					else:
						aes_data = raw_input("Please enter the message: ")
						aes_data = aes_padding(aes_data)
						aes_key = pick_key()
						i_v = raw_input("Please enter the initialization vector: ")
						while(len(str(i_v))<32):
							print 'Recommended: 0102030405060708090a0b0c0d0e0f10'
							i_v = raw_input("Please enter a correctly sized initialization vector: ")

					print 'Decrypted message: ',CBC_decrypt(aes_data, aes_key, i_v)


			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==2):
			key_pair_res = key_generation(input("Please enter the length (suggested: 1024): "))

			print 'Press 1 to save the public key'
			print 'Press 2 to save the private key'
			print 'Press 3 to save both keys'

			rsa_key_choice = input("Make your choice: ")

			rsa_file_name = "rsa_file"

			if(rsa_key_choice==1):
				rsa_file_name = rsa_file_name + ".pub"
				file_write_line(rsa_file_name, 'Public Key(e, n): \n'+'\n'+str(key_pair_res[0][0])+'\n'+str(key_pair_res[1][1]))
			elif(rsa_key_choice==2):
				rsa_file_name = rsa_file_name + ".sec"
				secure_pk = ECB_encrypt(key_pair_res[1][0], pick_key())
				file_write_line(rsa_file_name, 'Private Key(d, n): \n'+'\n'+str(secure_pk)+'\n'+str(key_pair_res[1][1]))
			elif(rsa_key_choice==3):
				rsa_file_name = rsa_file_name + ".pair"
				secure_pk = ECB_encrypt(key_pair_res[1][0], pick_key())
				file_write_line(rsa_file_name, 'Public Key(e, n): \n\n'+str(key_pair_res[0][0])+'\n'+str(key_pair_res[1][1])+'\n'+'\nPrivate Key(d, n): \n'+'\n'+str(secure_pk)+'\n'+str(key_pair_res[1][1]))

			if(input("Recommended: Press 1 if you wish to automatically use the generated keys for options 3 and 5: ")==1):
				e = key_pair_res[0][0]
				n = key_pair_res[1][1]
				d = key_pair_res[1][0]
				flag_option = 1

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==3):
			print 'Press 1 for Encryption'
			print 'Press 2 for Decryption'

			extra_option_1 = input("Make your choice: ")

			if(extra_option_1==1):
				m = raw_input("Please enter the plaintext: ")
				if(flag_option==0):
					e = input("Please enter the public key: ")
					n = input("Please enter the modulo: ")

				rsa_enc = rsa_encrypt(m, e, n)
				print 'Encrypted message (as a byte array): ',rsa_enc

			elif(extra_option_1==2):
				choice3 = input('Press 1 if you wish to decrypt the message you just encrypted: ')

				if(choice3==1 or flag_option==1):
					c = rsa_enc
					n = n
				else:
					c = raw_input("Please enter the ciphertext as a byte array: ")
					n = input("Please enter the modulo: ")

				if(flag_option==1):
					d = d
				else:
					d = input("Please enter the private key: ")

				print 'Decrypted message: ',rsa_decrypt(c, d, n)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==4):
			msg_4 = raw_input("Please enter the message: ")
			
			print 'Hashed message: ',SHA256(msg_4)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==5):
			print 'Press 1 for Sign'
			print 'Press 2 for Verification'

			extra_option_2 = input("Make your choice: ")

			if(extra_option_2==1):
				m = raw_input("Please enter the plaintext: ")
				if(flag_option==1):
					d = d
					n = n
				else:
					d = input("Please enter the private key: ")
					n = input("Please enter the modulo: ")

				digital_signature = sign(m, d, n)
				print 'Signed: ',digital_signature

			elif(extra_option_2==2):
				choice5 = input('Press 1 if you wish to verify the signature you just signed: ')

				if(choice5==1):
					m = m
					n = n
					c = digital_signature
				else:
					m = raw_input("Please enter the plaintext: ")
					c = raw_input("Please enter the ciphertext: ")
					n = input("Please enter the modulo: ")

				if(flag_option==1):
					e = e
				else:
					e = input("Please enter the public key: ")

				print 'Verified: ',verify(m, c, e, n)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==6):
			print 'If you wish to do AES with this password, you can do so in option 1'

			pw = raw_input("Please enter your password: ")

			print 'Hashed password: ',generate_hashed_password(pw)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0



def main_func():

	option = 10
	mode = 'a'
	rsa_enc = [1467475930L, 573131644L, 139212273L]
	flag_option = 0

	while(option!=0):

		print 'Press 1 to select AES Encryption'
		print 'Press 2 to select AES Decryption'
		print 'Press 3 to select SHA2 Hashing'
		print 'Press 4 to select Signature Signing'
		print 'Press 5 to select Signature Verification'
		print 'Press 6 to select Certificate Verification'
		print 'Press 0 to Exit'

		option = input("Make your choice: ")

		if(option==1):
			
			print "AES encrypt"
			#aes_data = raw_input("Please enter the message: ")
			print "Suggested: aes_plaintext_file.txt"
			aes_plaintext_file_name = raw_input("Please enter the name of the file containing the plaintext: ")
			aes_data = file_read(aes_plaintext_file_name)
			aes_data = aes_padding(aes_data)
			print 'Original message: ',aes_data
			#aes_key = pick_key()
			aes_key = raw_input("Please enter the key: ")

			i_v = '0102030405060708090a0b0c0d0e0f10'

			#i_v = raw_input("Please enter the initialization vector: ")
			#while(len(str(i_v))<32):
			#	print 'Recommended: 0102030405060708090a0b0c0d0e0f10'
			#	i_v = raw_input("Please enter a correctly sized initialization vector: ")

			cbc_enc = CBC_encrypt(aes_data, aes_key, i_v)
			print 'Encrypted message: ',cbc_enc

			aes_enc_file_name = "aes_enc_file.txt"
			file_write(aes_enc_file_name, cbc_enc)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==2):

			print "AES decrypt"
			choice1 = input('Press 1 if you wish to decrypt the message you just encrypted: ')
			print "Suggested: aes_enc_file.txt"
			aes_encrypted_file_name = raw_input("Please enter the name of the file containing the encrypted text: ")

			if(choice1==1):
				aes_key = aes_key
				aes_data = file_read(aes_encrypted_file_name)
				i_v = i_v
			else:
				#aes_data = raw_input("Please enter the message: ")
				aes_data = file_read(aes_encrypted_file_name)
				#aes_data = aes_padding(aes_data) WHY
				#aes_key = pick_key()
				aes_key = raw_input("Please enter the key: ")
				i_v = '0102030405060708090a0b0c0d0e0f10'

				#i_v = raw_input("Please enter the initialization vector: ")
				#while(len(str(i_v))<32):
				#	print 'Recommended: 0102030405060708090a0b0c0d0e0f10'
				#	i_v = raw_input("Please enter a correctly sized initialization vector: ")

			cbc_dec = CBC_decrypt(aes_data, aes_key, i_v)
			print 'Decrypted message: ',cbc_dec

			aes_dec_file_name = "aes_dec_file.txt"
			file_write(aes_dec_file_name, cbc_dec)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==3):

			print "sha256 hash"
			print "Suggested: sha256_file.txt"
			sha_file_name = raw_input("Please enter the name of the file containing the plaintext to be hashed: ")
			msg_4 = file_read(sha_file_name)
			#msg_4 = raw_input("Please enter the message: ")
			
			hashed_msg = SHA256(msg_4)
			print 'Hashed message: ',hashed_msg

			hashed_file_name = "hashed_file.txt"
			file_write(hashed_file_name, hashed_msg)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==4):

			print "RSA based Signature"
			sign_file_name = raw_input("Please enter the name of the file to be signed: ")
			private_key_file_name = raw_input("Please enter the name of the file containing the RSA private key: ")
			#m = raw_input("Please enter the plaintext: ")
			m = file_read(sign_file_name)

			#if(flag_option==1):
			#	d = d
			#	n = n
			#else:
			#	d = input("Please enter the private key: ")
			#	n = input("Please enter the modulo: ")

			d = file_read(private_key_file_name)
			n = input("Please enter the modulo: ")

			digital_signature = sign(m, d, n)
			print 'Signed: ',digital_signature

			signed_file_name = "signed_file.txt"
			file_write(sign_file_name, digital_signature)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==5):

			print "Signature verification"
			sign_file_name = raw_input("Please enter the name of the file containing the digital signature: ")
			print "Suggested: sign_file.txt"
			choice5 = input('Press 1 if you wish to verify the signature you just signed: ')

			if(choice5==1):
				m = m
				n = n
				c = digital_signature
			else:
				#m = raw_input("Please enter the plaintext: ")
				m = raw_input("Please enter the name of the signed file: ")
				#c = raw_input("Please enter the ciphertext: ")
				c = raw_input("Please enter the name of the file containing the signature: ")
				n = input("Please enter the modulo: ")

			if(flag_option==1):
				e = e
			else:
				e = input("Please enter the public key: ")

			print 'Verified: ',verify(m, c, e, n)

			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0

		elif(option==6):
			print "Certificate verification"

			cert_ver = crypto.load_certificate(crypto.FILETYPE_PEM, open("myapp.crt", "r").read())

			issuer = cert_ver.get_issuer().get_components()
			expiration = cert_ver.get_notAfter()

			year = expiration[0:4]
			month = expiration[4:6]
			day = expiration[6:8]
			hour = expiration[8:10]
			mins = expiration[10:12]
			secs = expiration[12:14]

			iss = issuer[-1][1]

			subj = cert_ver.get_subject().get_components()
			subj = subj[-1][1]

			if(cert_ver.has_expired()==False and iss==subj):
				print "True"
				return True
			else:
				print "False"
				return False


			if(input("Press 0 to exit or any other key to continue: ")==0):
				option = 0




#my_main()
#main_func()